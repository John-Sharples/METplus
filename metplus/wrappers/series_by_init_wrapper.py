'''! @namespace SeriesByInitWrapper
@brief Performs any optional filtering of input tcst data then performs
regridding via the MET tool regrid_data_plane, then builds up
the commands to perform a series analysis by init time by invoking the
MET tool series_analysis. NetCDF plots are generated by invoking the MET tool
plot_data_plane. The NetCDF plots are then converted to .png and Postscript.

Call as follows:
@code{.sh}
series_by_init.py [-c /path/to/user.template.conf]
@endcode
'''

import errno
import os
import re
import sys
from datetime import datetime

from ..util import met_util as util
from ..util import ti_calculate, do_string_sub
from .plot_data_plane_wrapper import PlotDataPlaneWrapper
from . import CommandBuilder

class SeriesByInitWrapper(CommandBuilder):
    """!  Performs series analysis based on init time by first performing any
          additional filtering via the wrapper to the MET tool tc_stat,
          tc_stat_wrapper.  Next, the arguments to run the MET tool
          series_analysis is done
    """
    FCST_ASCII_FILE_PREFIX = 'FCST_ASCII_FILES_'
    ANLY_ASCII_FILE_PREFIX = 'ANLY_ASCII_FILES_'

    def __init__(self, config, instance=None, config_overrides={}):
        self.app_path = os.path.join(config.getdir('MET_BIN_DIR', ''),
                                     'series_analysis')
        self.app_name = os.path.basename(self.app_path)
        super().__init__(config,
                         instance=instance,
                         config_overrides=config_overrides)

        self.plot_data_plane = self.plot_data_plane_init()

        self.logger.debug("Initialized SeriesByInitWrapper")

    def create_c_dict(self):
        c_dict = super().create_c_dict()
        c_dict['MODEL'] = self.config.getstr('config',
                                             'MODEL',
                                             'FCST')
        c_dict['REGRID_TO_GRID'] = (
            self.config.getstr('config',
                               'SERIES_ANALYSIS_REGRID_TO_GRID',
                               '')
        )

        # get stat list to loop over
        c_dict['STAT_LIST'] = util.getlist(
            self.config.getstr('config',
                               'SERIES_ANALYSIS_STAT_LIST',
                               '')
        )
        if not c_dict['STAT_LIST']:
            self.log_error("Must set SERIES_ANALYSIS_STAT_LIST to run.")

        # set stat list to set output_stats.cnt in MET config file
        self.set_c_dict_list(c_dict,
                             'SERIES_ANALYSIS_STAT_LIST',
                             'cnt',
                             'OUTPUT_STATS_CNT')

        c_dict['TILE_INPUT_DIR'] = self.config.getdir('SERIES_ANALYSIS_TILE_INPUT_DIR',
                                                 '')
        if not c_dict['TILE_INPUT_DIR']:
            self.log_error("Must set SERIES_ANALYSIS_TILE_INPUT_DIR")

        c_dict['STAT_INPUT_DIR'] = (
            self.config.getdir('SERIES_ANALYSIS_STAT_INPUT_DIR', '')
        )

        c_dict['STAT_INPUT_TEMPLATE'] = (
            self.config.getraw('config',
                               'SERIES_ANALYSIS_STAT_INPUT_TEMPLATE')
        )
        if not c_dict['STAT_INPUT_TEMPLATE']:
            self.log_error("Must set SERIES_ANALYSIS_STAT_INPUT_TEMPLATE")

        c_dict['OUTPUT_DIR'] = self.config.getdir('SERIES_ANALYSIS_OUTPUT_DIR',
                                                  '')
        c_dict['OUTPUT_TEMPLATE'] = (
            self.config.getraw('config',
                               'SERIES_ANALYSIS_OUTPUT_TEMPLATE')
        )
        if not c_dict['OUTPUT_DIR']:
            self.log_error("Must set SERIES_ANALYSIS_OUTPUT_DIR to run.")

        c_dict['FILTERED_OUTPUT_DIR'] = (
            self.config.getdir('SERIES_ANALYSIS_FILTERED_OUTPUT_DIR',
                               '')
        )

        c_dict['CONVERT_EXE'] = self.config.getexe('CONVERT')
        if not c_dict['CONVERT_EXE']:
            self.isOK = False

        c_dict['TC_STAT_OUTPUT_TEMPLATE'] = self.config.getraw('config',
                                                               'TC_STAT_OUTPUT_TEMPLATE')

        c_dict['FCST_TILE_PREFIX'] = self.config.getstr('config',
                                              'FCST_EXTRACT_TILES_PREFIX',
                                              '')
        if not c_dict['FCST_TILE_PREFIX']:
            self.log_error("Must set FCST_EXTRACT_TILES_PREFIX")

        c_dict['ANLY_TILE_PREFIX'] = self.config.getstr('config',
                                              'OBS_EXTRACT_TILES_PREFIX',
                                              '')
        if not c_dict['ANLY_TILE_PREFIX']:
            self.log_error("Must set OBS_EXTRACT_TILES_PREFIX")

        c_dict['FCST_TILE_REGEX'] = (
            f".*{c_dict['FCST_TILE_PREFIX']}.*nc"
        )

        c_dict['ANLY_TILE_REGEX'] = (
            f".*{c_dict['ANLY_TILE_PREFIX']}.*nc"
        )

        c_dict['CONFIG_FILE'] = self.config.getstr('config',
                                                   'SERIES_ANALYSIS_CONFIG_FILE',
                                                   '')
        if not c_dict['CONFIG_FILE']:
            self.log_error("SERIES_ANALYSIS_CONFIG_FILE must be set")

        c_dict['BACKGROUND_MAP'] = self.config.getbool('config',
                                             'SERIES_ANALYSIS_BACKGROUND_MAP',
                                             False)

        c_dict['VAR_LIST'] = util.parse_var_list(self.config)
        if not c_dict['VAR_LIST']:
            self.log_error("No fields specified. Please set "
                           "[FCST/OBS]_VAR<n>_[NAME/LEVELS]")

        return c_dict

    def plot_data_plane_init(self):
        # set values to allow successful initialization of PlotDataPlaneWrapper
        plot_overrides = {'PLOT_DATA_PLANE_INPUT_TEMPLATE': 'template',
                          'PLOT_DATA_PLANE_OUTPUT_TEMPLATE': 'template',
                          'PLOT_DATA_PLANE_FIELD_NAME': 'field_name',
                          }

        if not self.c_dict['BACKGROUND_MAP']:
            plot_overrides['PLOT_DATA_PLANE_FIELD_EXTRA'] = (
                "map_data={ source=[];}"
            )

        pdp_wrapper = PlotDataPlaneWrapper(self.config,
                                           config_overrides=plot_overrides)
        return pdp_wrapper


    def run_at_time(self, input_dict):
        """! Invoke the series analysis script based on
            the init time in the format YYYYMMDD_hh

            Args:

            Returns:
                None:  Creates graphical plots of storm tracks
        """
        self.logger.debug("Starting series analysis by init time")

        # Calculate other time information from available time info
        time_info = ti_calculate(input_dict)

        storm_list = self.get_storms_for_init(time_info)
        if not storm_list:
            # No storms for this init time, check next init time in list
            self.logger.debug(f"No storms found for current init time")
            return False

        # Check for input tile data.
        try:
            util.check_for_tiles(self.c_dict['TILE_INPUT_DIR'],
                                 self.c_dict['FCST_TILE_REGEX'],
                                 self.c_dict['ANLY_TILE_REGEX'], self.logger)
        except OSError:
            self.log_error("Missing n x m tile files. "
                           "ExtractTiles must be run before this wrapper")
            return False

        # Create FCST and ANLY ASCII files based on init time and storm id.
        # These are arguments to the
        # -fcst and -obs arguments to the MET Tool series_analysis.
        # First, get an updated list of init times,
        # since filtering can reduce the amount of init times.
        self.get_ascii_storm_files_list(time_info, storm_list)

        # Build up the arguments to and then run the MET tool series_analysis.
        if not self.build_and_run_series_request(time_info, storm_list):
            return False

        self.generate_plots(time_info, storm_list)

        self.logger.debug("Finished series analysis by init time")
        return True

    def get_fcst_file_info(self, fcst_path):
        """! Get the number of all the gridded forecast n x m tile
            files for a given storm id and init time
            (that were created by extract_tiles). Determine the filename of the
            first and last files.  This information is used to create
            the title value to the -title opt in plot_data_plane.

            @param fcst_path path to file list ASCII file that contains a list
             paths to forecast files to process
            @returns num, beg, end:  A tuple representing the number of
            forecast tile files, and the first and last file. If info cannot
            be parsed, return (None, None, None)
        """
        with open(fcst_path, 'r') as file_handle:
            files_of_interest = file_handle.readlines()

        # Get a sorted list of the forecast tile files for the init
        # time of interest for all the storm ids and return the
        # forecast hour corresponding to the first and last file.
        sorted_files = sorted(files_of_interest)
        if not files_of_interest:
            self.log_error(f"No files found in file list: {fcst_path}")
            return None, None, None

        first = sorted_files[0]
        last = sorted_files[-1]

        # Extract the forecast hour from the first and last filenames.
        fcst_regex = f".*{self.c_dict['FCST_TILE_PREFIX']}" + "([0-9]{3}).*.nc"
        match_beg = re.search(fcst_regex, first)
        match_end = re.search(fcst_regex, last)

        if match_beg:
            beg = f"F{match_beg.group(1)}"
        else:
            self.log_error("Unexpected file format encountered, exiting...")
            return None, None, None

        if match_end:
            end = f"F{match_end.group(1)}"
        else:
            self.log_error("Unexpected file format encountered, exiting...")
            return None, None, None

        # Get the number of forecast tile files
        num = len(sorted_files)

        return num, beg, end

    def get_ascii_storm_files_list(self, time_info, storm_list):
        """! Creates the list of ASCII files that contain the storm id and init
             times.  The list is used to create an ASCII file which will be
             used as the option to the -obs or -fcst flag to the MET
             series_analysis tool.
             Args:
                   @param tile_dir:  The directory where input files reside.
             Returns:
                   sorted_filter_init:  A list of the sorted directories
                                        corresponding to the init times after
                                        filtering has been applied.  If
                                        filtering produced no results, this
                                        is the list of files created from
                                        running extract_tiles.
        """
        cur_init = time_info['init'].strftime('%Y%m%d_%H')
        for storm_id in storm_list:
            # First get the filenames for the gridded forecast and
            # analysis (n deg x m deg tiles that were created by
            # extract_tiles). These files are aggregated by
            # init time and storm id.
            anly_grid_files = util.get_files(self.c_dict['TILE_INPUT_DIR'],
                                             self.c_dict['ANLY_TILE_REGEX'],
                                             self.logger)
            fcst_grid_files = util.get_files(self.c_dict['TILE_INPUT_DIR'],
                                             self.c_dict['FCST_TILE_REGEX'],
                                             self.logger)

            # Now do some checking to make sure we aren't
            # missing either the forecast or
            # analysis files, if so log the error and proceed to next
            # storm in the list.
            if not anly_grid_files or not fcst_grid_files:
                # No gridded analysis or forecast
                # files found, continue
                self.logger.info("no gridded analysis or forecast " +
                                 "file found, continue to next storm")
                continue

            # Now create the FCST and ANLY ASCII files based on
            # cur_init and storm_id:
            self.create_fcst_anly_to_ascii_file(
                fcst_grid_files, cur_init, storm_id,
                self.FCST_ASCII_FILE_PREFIX)
            self.create_fcst_anly_to_ascii_file(
                anly_grid_files, cur_init, storm_id,
                self.ANLY_ASCII_FILE_PREFIX)

        self.logger.debug("Finished creating FCST and ANLY ASCII files")

    def build_and_run_series_request(self, time_info, storm_list):
        """! Build up the -obs, -fcst, -out necessary for running the
             series_analysis MET tool, then invoke series_analysis.

             @param time_info dictionary containing time information for
             current run
             @param storm_list list of storms IDs to process
             @returns True if all runs succeeded, False if there was a problem
             with any of the runs
        """
        # Now assemble the -fcst, -obs, and -out arguments and invoke the
        # MET Tool: series_analysis.
        success = True
        output_dir_template = os.path.join(self.c_dict['OUTPUT_DIR'],
                                       self.c_dict['OUTPUT_TEMPLATE'])
        output_dir_template = os.path.dirname(output_dir_template)
#        cur_init = time_info['init'].strftime('%Y%m%d_%H')
        for storm_id in storm_list:
            time_info['storm_id'] = storm_id

            output_dir = do_string_sub(output_dir_template,
                                       **time_info)
            fcst_path = os.path.join(output_dir,
                                     f"{self.FCST_ASCII_FILE_PREFIX}{storm_id}")
            obs_path = os.path.join(output_dir,
                                    f"{self.ANLY_ASCII_FILE_PREFIX}{storm_id}")

            # Build the -obs and -fcst portions of the series_analysis
            # command. Then generate the -out portion, get the NAME and
            # corresponding LEVEL for each variable.
            for var_info in self.c_dict['VAR_LIST']:
                self.infiles.append(f"-fcst {fcst_path}")
                self.infiles.append(f"-obs {obs_path}")
                self.add_field_info_to_time_info(time_info, var_info)
                self.set_environment_variables(time_info, var_info)

                self.find_and_check_output_file(time_info)
                self.logger.debug(
                    f'output dir for series_analysis: {self.get_output_path()}'
                )

                if not self.build():
                    success = False
                self.clear()

        return success

    def set_environment_variables(self, time_info, var_info):
        """! Set the env variables based on settings in the METplus config
             files.
        """
        self.logger.info('Setting env variables from config file...')

        # Set all the environment variables that are needed by the
        # MET config file.
        # Set up the environment variable to be used in the Series Analysis
        tmp_stat_string = str(self.c_dict['STAT_LIST'])
        tmp_stat_string = tmp_stat_string.replace("\'", "\"")
        os.environ['STAT_LIST'] = tmp_stat_string
        self.add_env_var('STAT_LIST', tmp_stat_string)
        #        self.add_env_var('STAT_LIST', self.c_dict.get('OUTPUT_STATS_CNT', ''))

        # set MODEL and REGRID_TO_GRID environment variables
        self.add_common_envs()

        # Set the NAME and LEVEL environment variables
        self.add_env_var('NAME', var_info['fcst_name'])
        self.add_env_var('LEVEL', var_info['fcst_level'])

        super().set_environment_variables(time_info)

    def create_out_arg(self, storm_id, cur_init, name, level):
        """! Create/build the -out portion of the series_analysis command and
             creates the output directory.
            Args:
                @param storm_id: The storm of interest.

                @param cur_init:  The initialization time of interest.

                @param name:  The variable name of interest.

                @param level:  The level of interest.

            Returns:
        """
        # Set the sbi_out_dir for this instance, this will be
        # used for generating the plot.
        self.c_dict['PLOTTING_DIR'] = ''.join(
            series_anly_output_parts)
        self.outfile = self.c_dict['PLOTTING_DIR']



    def get_command(self):
        cmd = self.app_path + " "

        cmd += ' '.join(self.infiles)

        cmd += f" -config {self.c_dict['CONFIG_FILE']}"

        if self.get_output_path() == "":
            self.logger.info("No output directory specified, because series analysis has multiple directories")
            self.logger.info("No output filename specified, because series analysis has multiple files")
        else:
            cmd += " -out " + os.path.join(self.get_output_path())

        return cmd

    def generate_plots(self, time_info, storm_list):
        """! Generate the plots from the series_analysis output.
           Args:
               @param sorted_filter_init:  A list of the sorted directories
                                        corresponding to the init times (that
                                        are the result of filtering).  If
                                        filtering produced no results, this
                                        is the list of files created from
                                        running extract_tiles.

               @param tile_dir:  The directory where input data resides.
           Returns:
        """
        cur_init = time_info['init'].strftime('%Y%m%d_%H')
        for var_info in self.c_dict['VAR_LIST']:
            name = var_info['fcst_name']
            level = var_info['fcst_level']
            self.add_field_info_to_time_info(time_info, var_info)

            for storm_id in storm_list:
                time_info['storm_id'] = storm_id
                # get the output directory where the series_analysis output
                # was written. Plots will be written to the same directory
                output_template = os.path.join(self.c_dict['OUTPUT_DIR'],
                                               self.c_dict['OUTPUT_TEMPLATE'])
                plot_input = do_string_sub(output_template,
                                           **time_info)
                output_dir = os.path.dirname(plot_input)

                fcst_path = os.path.join(output_dir,
                                         f"{self.FCST_ASCII_FILE_PREFIX}{storm_id}")
                # Now we need to invoke the MET tool
                # plot_data_plane to generate plots that are
                # recognized by the MET viewer.
                # Get the number of forecast tile files,
                # the name of the first and last in the list
                # to be used by the -title option.
                num, beg, end = self.get_fcst_file_info(fcst_path)
                if num is None:
                    self.logger.debug(f"Skipping plot for {storm_id}")
                    continue

                # Assemble the input file, output file, field string, and title
                for cur_stat in self.c_dict['STAT_LIST']:
                    plot_output = (f"{os.path.splitext(plot_input)[0]}_"
                                  f"{cur_stat}.ps")
                    os.environ['CUR_STAT'] = cur_stat
                    self.plot_data_plane.add_env_var('CUR_STAT', cur_stat)

                    title = (f"{self.c_dict['MODEL']} "
                             f"Init {cur_init} "
                             f"Storm {storm_id} {num} Forecasts ({beg} to "
                             f"{end}) {cur_stat} for {name}, {level}")

                    self.plot_data_plane.c_dict['TITLE'] = title
                    self.plot_data_plane.c_dict['INPUT_TEMPLATE'] = plot_input
                    self.plot_data_plane.c_dict['OUTPUT_TEMPLATE'] = plot_output
                    self.plot_data_plane.c_dict['FIELD_NAME'] = f"series_cnt_{cur_stat}"
                    self.plot_data_plane.c_dict['FIELD_LEVEL'] = level
                    self.plot_data_plane.run_at_time_once(time_info)

                    # Now assemble the command to convert the
                    # postscript file to png
                    png_fname = f"{os.path.splitext(plot_output)[0]}.png"
                    convert_parts = [self.c_dict['CONVERT_EXE'], ' -rotate 90',
                                     ' -background white -flatten ',
                                     plot_output,
                                     ' ', png_fname]
                    convert_command = ''.join(convert_parts)

                    (ret, cmd) = self.cmdrunner.run_cmd(convert_command,
                                                        ismetcmd=False)
                    if ret:
                        self.log_error(f"convert returned a non-zero return code: {cmd}")
                        self.logger.info("Check the logfile for more information on why it failed")

    def get_storms_for_init(self, time_info):
        """! Retrieve all the filter files which have the .tcst
             extension.  Inside each file, extract the STORM_ID
             and append to the list, if the storm_list directory
             exists.

            Args:
              @param cur_init: the init time

              @param out_dir_base:  The directory where one should start
                                    searching for the filter file(s)
                                    - those with a .tcst file extension.


        Returns:
            storm_list: A list of all the storms ids that correspond to
                        this init time and actually has a directory in the
                        init dir (additional filtering in a previous step
                        may result in missing storm ids even though they are
                        in the filter.tcst file)
        """
        # Retrieve filter files, first create the filename
        # by piecing together the out_dir_base with the cur_init.
        filter_template = os.path.join(self.c_dict['STAT_INPUT_DIR'],
                                       self.c_dict['STAT_INPUT_TEMPLATE'])
        filter_file = do_string_sub(filter_template, **time_info)
        self.logger.debug(f"Getting storms from filter file: {filter_file}")
        if not os.path.exists(filter_file):
            self.log_error("Filter file does not exist!")
            return None

        # Now that we have the filter filename for the init time, let's
        # extract all the storm ids in this filter file.
        storm_list = util.get_storm_ids(filter_file, self.logger)

        return storm_list

    def create_fcst_anly_to_ascii_file(self, fcst_anly_grid_files, cur_init,
                                       storm_id, fcst_anly_filename_base):
        """! Create ASCII file for either the FCST or ANLY files that are
             aggregated based on init time and storm id.

        Args:
            fcst_anly_grid_files:       A list of the FCST or ANLY gridded
                                        files under consideration.

            cur_init:                  The initialization time of interest

            storm_id:                 The storm id of interest

            fcst_anly_filename_base:   The base name of the ASCII file
                                        (either ANLY_ASCII_FILES_ or
                                        FCST_ASCII_FILES_ which will be
                                        appended with the storm id.

        Returns:
            None:                      Creates an ASCII file containing a list
                                        of either FCST or ANLY files based on
                                        init time and storm id.
        """
        # Create an ASCII file containing a list of all
        # the fcst or analysis tiles.
        fcst_anly_ascii_fname_parts = [fcst_anly_filename_base, storm_id]
        fcst_anly_ascii_fname = ''.join(fcst_anly_ascii_fname_parts)
        fcst_anly_ascii_dir = os.path.join(self.c_dict['OUTPUT_DIR'], cur_init,
                                           storm_id)

        fcst_anly_ascii = os.path.join(fcst_anly_ascii_dir,
                                       fcst_anly_ascii_fname)

        # Sort the files in the fcst_anly_grid_files list.
        sorted_fcst_anly_grid_files = sorted(fcst_anly_grid_files)
        tmp_param = ''
        for cur_fcst_anly in sorted_fcst_anly_grid_files:
            # Write out the files that pertain to this storm and
            # don't write if already in tmp_param.
            if cur_fcst_anly not in tmp_param and storm_id in cur_fcst_anly:
                tmp_param += cur_fcst_anly
                tmp_param += '\n'

        if not tmp_param:
            self.logger.debug(f"No files found to write to {fcst_anly_ascii}")
            return False

        util.mkdir_p(fcst_anly_ascii_dir)

        # Now create the fcst or analysis ASCII file
        try:
            with open(fcst_anly_ascii, 'w') as filehandle:
                filehandle.write(tmp_param)
        except IOError:
            msg = ("Could not create requested ASCII file:  " +
                   fcst_anly_ascii)
            self.log_error(msg)
            return False

        return True
