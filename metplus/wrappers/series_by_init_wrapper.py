'''! @namespace SeriesByInitWrapper
@brief Performs any optional filtering of input tcst data then performs
regridding via the MET tool regrid_data_plane, then builds up
the commands to perform a series analysis by init time by invoking the
MET tool series_analysis. NetCDF plots are generated by invoking the MET tool
plot_data_plane. The NetCDF plots are then converted to .png and Postscript.

Call as follows:
@code{.sh}
series_by_init.py [-c /path/to/user.template.conf]
@endcode
'''

import errno
import os
import re
import sys
from datetime import datetime

from ..util import met_util as util
from .tc_stat_wrapper import TCStatWrapper
from ..util import feature_util
from . import CommandBuilder

class SeriesByInitWrapper(CommandBuilder):
    """!  Performs series analysis based on init time by first performing any
          additional filtering via the wrapper to the MET tool tc_stat,
          tc_stat_wrapper.  Next, the arguments to run the MET tool
          series_analysis is done
    """
    FCST_ASCII_FILE_PREFIX = 'FCST_ASCII_FILES_'
    ANLY_ASCII_FILE_PREFIX = 'ANLY_ASCII_FILES_'
    anly_grid_regex = ".*ANLY_TILE_F.*nc"
    fcst_grid_regex = ".*FCST_TILE_F.*nc"

    def __init__(self, config):
        self.app_path = os.path.join(config.getdir('MET_BIN_DIR', ''),
                                     'series_analysis')
        self.app_name = os.path.basename(self.app_path)
        super().__init__(config)

        self.logger.debug("Initialized SeriesByInitWrapper")

    def create_c_dict(self):
        c_dict = super().create_c_dict()
        c_dict['MODEL'] = self.config.getstr('config',
                                             'MODEL',
                                             'FCST')
        c_dict['REGRID_TO_GRID'] = (
            self.config.getstr('config',
                               'SERIES_ANALYSIS_REGRID_TO_GRID',
                               '')
        )

        # get stat list to loop over
        c_dict['STAT_LIST'] = util.getlist(
            self.config.getstr('config',
                               'SERIES_ANALYSIS_STAT_LIST')
        )
        # set stat list to set output_stats.cnt in MET config file
        self.set_c_dict_list(c_dict,
                             'SERIES_ANALYSIS_STAT_LIST',
                             'cnt',
                             'OUTPUT_STATS_CNT')

        c_dict['SERIES_FILTER_OPTS'] = (
            self.config.getstr('config', 'SERIES_ANALYSIS_FILTER_OPTS')
        )

        c_dict['INPUT_DIR'] = self.config.getdir('SERIES_ANALYSIS_INPUT_DIR',
                                                 '')
        if not c_dict['INPUT_DIR']:
            self.log_error("Must set SERIES_ANALYSIS_INPUT_DIR")

        c_dict['OUTPUT_DIR'] = self.config.getdir('SERIES_ANALYSIS_OUTPUT_DIR',
                                                  '')
        if not c_dict['OUTPUT_DIR']:
            self.log_error("Must set SERIES_ANALYSIS_OUTPUT_DIR to run.")

        c_dict['FILTERED_OUTPUT_DIR'] = (
            self.config.getdir('SERIES_ANALYSIS_FILTERED_OUTPUT_DIR',
                               '')
        )

        c_dict['CONVERT_EXE'] = self.config.getexe('CONVERT')
        if not c_dict['CONVERT_EXE']:
            self.isOK = False

        c_dict['TC_STAT_OUTPUT_TEMPLATE'] = self.config.getraw('config',
                                                               'TC_STAT_OUTPUT_TEMPLATE')

        c_dict['FCST_EXTRACT_TILES_PREFIX'] = self.config.getstr('config',
                                                                 'FCST_EXTRACT_TILES_PREFIX',
                                                                 '')
        if not c_dict['FCST_EXTRACT_TILES_PREFIX']:
            self.log_error("Must set FCST_EXTRACT_TILES_PREFIX")

        c_dict['OBS_EXTRACT_TILES_PREFIX'] = self.config.getstr('config',
                                                                'OBS_EXTRACT_TILES_PREFIX',
                                                                '')
        if not c_dict['OBS_EXTRACT_TILES_PREFIX']:
            self.log_error("Must set OBS_EXTRACT_TILES_PREFIX")

        c_dict['FCST_TILE_REGEX'] = (
            self.config.getstr('regex_pattern',
                               'FCST_SERIES_ANALYSIS_NC_TILE_REGEX',
                               '')
        )
        if not c_dict['FCST_TILE_REGEX']:
            self.log_error("Must set FCST_SERIES_ANALYSIS_NC_TILE_REGEX")

        c_dict['ANLY_TILE_REGEX'] = (
            self.config.getstr('regex_pattern',
                               'OBS_SERIES_ANALYSIS_NC_TILE_REGEX',
                               '')
        )
        if not c_dict['FCST_TILE_REGEX']:
            self.log_error("Must set OBS_SERIES_ANALYSIS_NC_TILE_REGEX")

        c_dict['CONFIG_FILE'] = self.config.getstr('config',
                                                   'SERIES_ANALYSIS_CONFIG_FILE',
                                                   '')
        if not c_dict['CONFIG_FILE']:
            self.log_error("SERIES_ANALYSIS_CONFIG_FILE must be set")

        c_dict['BACKGROUND_MAP'] = self.config.getbool('config',
                                             'SERIES_ANALYSIS_BACKGROUND_MAP',
                                             False)
        c_dict['PLOT_DATA_PLANE'] = os.path.join(self.config.getdir('MET_BIN_DIR', ''),
                                           'plot_data_plane')

        return c_dict

    def run_all_times(self):
        """! Invoke the series analysis script based on
            the init time in the format YYYYMMDD_hh

            Args:

            Returns:
                None:  Creates graphical plots of storm tracks
        """
        self.logger.debug("Starting series analysis by init time")

        # Set up the environment variable to be used in the Series Analysis
        tmp_stat_string = str(self.c_dict['STAT_LIST'])
        tmp_stat_string = tmp_stat_string.replace("\'", "\"")
        os.environ['STAT_LIST'] = tmp_stat_string
#        self.add_env_var('STAT_LIST', self.c_dict.get('OUTPUT_STATS_CNT', ''))

        # Initialize the tile_dir to point to the c_dict['INPUT_DIR'].
        # And retrieve a list of init times based on the data available in
        # the extract tiles directory.
        tile_dir = self.c_dict['INPUT_DIR']
        init_times = util.get_updated_init_times(tile_dir, self.logger)

        # Check for input tile data.
        try:
            util.check_for_tiles(tile_dir, self.c_dict['FCST_TILE_REGEX'],
                                 self.c_dict['ANLY_TILE_REGEX'], self.logger)
        except OSError:
            self.log_error("Missing n x m tile files. "
                           "ExtractTiles must be run before this wrapper")
            return False

        # If applicable, apply any filtering via tc_stat, as indicated in the
        # parameter/config file.
#        staging_dir = self.config.getdir('STAGING_DIR')
        if self.c_dict['SERIES_FILTER_OPTS']:
            self.apply_series_filters(tile_dir, init_times)

            # Clean up any empty files and directories that could arise as
            # a result of filtering
            util.prune_empty(self.c_dict['FILTERED_OUTPUT_DIR'], self.logger)
            """
            # Get the list of all the files that were created as a result
            # of applying the filter options.
            # First, make sure that the series_lead_filtered_out
            # directory isn't empty.  If so, then no files fall within the
            # filter criteria.
            if os.path.exists(self.c_dict['FILTERED_OUTPUT_DIR']) and \
                    os.listdir(self.c_dict['FILTERED_OUTPUT_DIR']):
                # The series filter directory has data, use this directory as
                # input for series analysis.
                tile_dir = self.c_dict['FILTERED_OUTPUT_DIR']

                # Generate the tmp_anly and tmp_fcst files used to validate
                # filtering and for troubleshooting
                # The tmp_fcst and tmp_anly ASCII files contain the
                # list of files that meet the filter criteria.
                filtered_dirs_list = util.get_files(tile_dir, ".*.",
                                                    self.logger)
                util.create_filter_tmp_files(filtered_dirs_list,
                                             self.c_dict['FILTERED_OUTPUT_DIR'],
                                             self.logger)

            else:
                # Applying the filter produced no results.  Rather than
                # stopping, continue by using the files from extract_
                # tiles as input.
                msg = ("Applied series filter options, no results..." +
                       "using extract tiles data for series analysis input.")
                self.logger.debug(msg)
                tile_dir = self.c_dict['INPUT_DIR']
            """
#        else:
            # No additional filtering was requested.
            # Use the data in the extract tiles directory
            # as input for series analysis.
            # source of input tile data.
#        tile_dir = self.c_dict['INPUT_DIR']

        # Create FCST and ANLY ASCII files based on init time and storm id.
        # These are arguments to the
        # -fcst and -obs arguments to the MET Tool series_analysis.
        # First, get an updated list of init times,
        # since filtering can reduce the amount of init times.
        sorted_filter_init = self.get_ascii_storm_files_list(tile_dir)

        # Clean up any remaining empty files and dirs
        util.prune_empty(self.c_dict['OUTPUT_DIR'], self.logger)
        self.logger.debug("Finished creating FCST and ANLY ASCII files, and " +
                          "cleaning empty files and dirs")

        # Build up the arguments to and then run the MET tool series_analysis.
        self.build_and_run_series_request(sorted_filter_init, tile_dir)

        # Generate plots
        # Check for .nc files in output_dir first, if these are absent, the
        # there is a problem.
        if not self.is_netcdf_created():
            self.log_error("No NetCDF files were created by"
                           " series_analysis, exiting...")
            return False

        self.generate_plots(sorted_filter_init, tile_dir)

        # clean up the tmp dir now that we are finished and create a new empty
        # tmp dir
#        filtered_file_regex = "filter_.*"
#        util.remove_staged_files(staging_dir, filtered_file_regex, self.logger )

        self.logger.debug("Finished series analysis by init time")
        return True

    def apply_series_filters(self, tile_dir, init_times):

        """! Apply filter options, as specified in the
            param/config file.
            Args:
               @param tile_dir:  Directory where input data files reside.
                                 e.g. data which we will be applying our filter
                                 criteria.
               @param init_times:  List of init times that define the
                                   input data.
               @param staging_dir:  The staging directory where intermediate
                                      files are saved.
            Returns:
                None
        """
        for cur_init in init_times:
            # Call the tc_stat wrapper to build up the command and invoke
            # the MET tool tc_stat.
            filter_file = "filter_" + cur_init + ".tcst"
            filter_filename = os.path.join(self.c_dict['FILTERED_OUTPUT_DIR'],
                                           cur_init, filter_file)

            input_dict = {'init': datetime.strptime(cur_init, '%Y%m%d_%H')}
            job_args = (f"-job filter {self.c_dict['SERIES_FILTER_OPTS']}"
                        f' -dump_row {filter_filename}')
            override_dict = {'TC_STAT_JOB_ARGS': job_args,
                             'TC_STAT_INIT_INCLUDE': cur_init,
                             'TC_STAT_LOOKIN_DIR': tile_dir,
                             'TC_STAT_OUTPUT_DIR': self.c_dict['FILTERED_OUTPUT_DIR'],
                             'TC_STAT_MATCH_POINTS': True,
                             }
            tc_stat_wrapper = TCStatWrapper(self.config, override_dict)
            if not tc_stat_wrapper.isOK:
                self.log_error('TCStat wrapper did not initialize properly')
                continue

            if not tc_stat_wrapper.run_at_time(input_dict):
                self.log_error(f'TCStat wrapper failed for {cur_init}')
                continue

    def is_netcdf_created(self):
        """! Check for the presence of NetCDF files in the series_analysis_init
             directory

             Returns:
                 is_created         True if NetCDF files were found in the
                                    series_analysis_init/YYYYMMDD_hh/storm
                                    sub-directories, False otherwise.
        """
        dated_dir_list = os.listdir(self.c_dict['OUTPUT_DIR'])
        netcdf_file_counter = 0
        is_created = False

        # Get the storm sub-directories in each dated sub-directory
        for dated_dir in dated_dir_list:
            dated_dir_path = os.path.join(self.c_dict['OUTPUT_DIR'], dated_dir)
            # Get a list of the storm sub-dirs in this directory
            all_storm_list = os.listdir(dated_dir_path)
            for each_storm in all_storm_list:
                full_storm_dirname = os.path.join(dated_dir_path, each_storm)
                # Now get the list of files for each storm sub-dir.
                # skip if the path is not a directory
                if not os.path.isdir(full_storm_dirname):
                    continue

                all_files = os.listdir(full_storm_dirname)
                for each_file in all_files:
                    full_filepath = os.path.join(full_storm_dirname, each_file)
                    if os.path.isfile(full_filepath):
                        if full_filepath.endswith('.nc'):
                            netcdf_file_counter += 1

        if netcdf_file_counter > 0:
            is_created = True

        return is_created

    def get_fcst_file_info(self, fcst_path):
        """! Get the number of all the gridded forecast n x m tile
            files for a given storm id and init time
            (that were created by extract_tiles). Determine the filename of the
            first and last files.  This information is used to create
            the title value to the -title opt in plot_data_plane.

            Args:
            @param dir_to_search: The directory of the gridded files of
                                  interest.
            @param cur_init:  The init time of interest.
            @param cur_storm:  The storm id of interest.

            Returns:
            num, beg, end:  A tuple representing the number of
                            forecast tile files, and the first and
                            last file.

                            sys.exit(1) otherwise
        """
        with open(fcst_path, 'r') as file_handle:
            files_of_interest = file_handle.readlines()

        # Get a sorted list of the forecast tile files for the init
        # time of interest for all the storm ids and return the
        # forecast hour corresponding to the first and last file.
        # base_dir_to_search = os.path.join(output_dir, cur_init)
#        gridded_dir = os.path.join(dir_to_search, cur_init, cur_storm)
#        search_regex = ".*FCST_TILE.*.nc"

#        files_of_interest = util.get_files(gridded_dir, search_regex,
#                                           self.logger)
        sorted_files = sorted(files_of_interest)
        if not files_of_interest:
            msg = ("exiting, no files found for " +
                   "init time of interest" +
                   " and directory:" + dir_to_search)
            self.log_error(msg)
            sys.exit(1)

        first = sorted_files[0]
        last = sorted_files[-1]

        # Extract the forecast hour from the first and last
        # filenames.
        match_beg = re.search(".*FCST_TILE_(F[0-9]{3}).*.nc", first)
        match_end = re.search(".*FCST_TILE_(F[0-9]{3}).*.nc", last)

        if match_beg:
            beg = match_beg.group(1)
        else:
            msg = ("Unexpected file format encountered, exiting...")
            self.log_error(msg)
            sys.exit(1)

        if match_end:
            end = match_end.group(1)
        else:
            msg = ("Unexpected file format encountered, exiting...")
            self.log_error(msg)
            sys.exit(1)

        # Get the number of forecast tile files
        num = len(sorted_files)

        return num, beg, end

    def get_ascii_storm_files_list(self, tile_dir):
        """! Creates the list of ASCII files that contain the storm id and init
             times.  The list is used to create an ASCII file which will be
             used as the option to the -obs or -fcst flag to the MET
             series_analysis tool.
             Args:
                   @param tile_dir:  The directory where input files reside.
             Returns:
                   sorted_filter_init:  A list of the sorted directories
                                        corresponding to the init times after
                                        filtering has been applied.  If
                                        filtering produced no results, this
                                        is the list of files created from
                                        running extract_tiles.
        """
        filter_init_times = util.get_updated_init_times(tile_dir, self.logger)
        sorted_filter_init = sorted(filter_init_times)

        fcst_grid_regex = f".*{self.c_dict['FCST_EXTRACT_TILES_PREFIX']}.*nc"
        anly_grid_regex = f".*{self.c_dict['OBS_EXTRACT_TILES_PREFIX']}.*nc"

        for cur_init in sorted_filter_init:
            # Get all the storm ids for storm track pairs that
            # correspond to this init time.
            storm_list = self.get_storms_for_init(cur_init, tile_dir)
            if not storm_list:
                # No storms for this init time, check next init time in list
                continue

            for cur_storm in storm_list:
                # First get the filenames for the gridded forecast and
                # analysis (n deg x m deg tiles that were created by
                # extract_tiles). These files are aggregated by
                # init time and storm id.
                anly_grid_files = util.get_files(tile_dir,
                                                 anly_grid_regex,
                                                 self.logger)
                fcst_grid_files = util.get_files(tile_dir,
                                                 fcst_grid_regex,
                                                 self.logger)

                # Now do some checking to make sure we aren't
                # missing either the forecast or
                # analysis files, if so log the error and proceed to next
                # storm in the list.
                if not anly_grid_files or not fcst_grid_files:
                    # No gridded analysis or forecast
                    # files found, continue
                    self.logger.info("no gridded analysis or forecast " +
                                     "file found, continue to next storm")
                    continue

                # Now create the FCST and ANLY ASCII files based on
                # cur_init and cur_storm:
                self.create_fcst_anly_to_ascii_file(
                    fcst_grid_files, cur_init, cur_storm,
                    self.FCST_ASCII_FILE_PREFIX)
                self.create_fcst_anly_to_ascii_file(
                    anly_grid_files, cur_init, cur_storm,
                    self.ANLY_ASCII_FILE_PREFIX)
                util.prune_empty(self.c_dict['OUTPUT_DIR'], self.logger)
        return sorted_filter_init

    def build_and_run_series_request(self, sorted_filter_init, tile_dir):
        """! Build up the -obs, -fcst, -out necessary for running the
             series_analysis MET tool, then invoke series_analysis.

             Args:
                  @param sorted_filter_init:  A list of the sorted directories
                                        corresponding to the init times that
                                        are the result of filtering.  If
                                        filtering produced no results, this
                                        is the list of files created from
                                        running extract_tiles.
                  @param tile_dir:  The directory where the input resides.
             Returns:
        """
        # Now assemble the -fcst, -obs, and -out arguments and invoke the
        # MET Tool: series_analysis.
        for cur_init in sorted_filter_init:
            storm_list = self.get_storms_for_init(cur_init, tile_dir)
            for cur_storm in storm_list:
                if not storm_list:
                    # No storm ids found for cur_init
                    # check next init time in the list.
                    continue

                output_dir = os.path.join(self.c_dict['OUTPUT_DIR'],
                                          cur_init,
                                          cur_storm)
                fcst_path = os.path.join(output_dir,
                                         f"{self.FCST_ASCII_FILE_PREFIX}{cur_storm}")
                obs_path = os.path.join(output_dir,
                                        f"{self.ANLY_ASCII_FILE_PREFIX}{cur_storm}")

                # Build the -obs and -fcst portions of the series_analysis
                # command. Then generate the -out portion, get the NAME and
                # corresponding LEVEL for each variable.
                full_vars_list = feature_util.retrieve_var_name_levels(self.config)
                for cur_var in full_vars_list:
                    name, level = cur_var
                    self.infiles.append(f"-fcst {fcst_path}")
                    self.infiles.append(f"-obs {obs_path}")
                    self.create_out_arg(cur_storm, cur_init, name, level)
                    self.add_common_envs()
                    super().set_environment_variables()
                    self.build()
                    self.clear()

    def create_out_arg(self, cur_storm, cur_init, name, level):
        """! Create/build the -out portion of the series_analysis command and
             creates the output directory.
            Args:
                @param cur_storm: The storm of interest.

                @param cur_init:  The initialization time of interest.

                @param name:  The variable name of interest.

                @param level:  The level of interest.

            Returns:
        """
        # create the output dir
        outdir = os.path.join(self.c_dict['OUTPUT_DIR'], cur_init,
                                   cur_storm)
        util.mkdir_p(outdir)
        # Set the NAME and LEVEL environment variables, this
        # is required by the MET series_analysis binary.
        os.environ['NAME'] = name
        os.environ['LEVEL'] = level
        self.add_env_var('NAME', name)
        self.add_env_var('LEVEL', level)

        series_anly_output_parts = [outdir, '/',
                                    'series_', name, '_',
                                    level, '.nc']
        # Set the sbi_out_dir for this instance, this will be
        # used for generating the plot.
        self.c_dict['PLOTTING_DIR'] = ''.join(
            series_anly_output_parts)
        self.outfile = self.c_dict['PLOTTING_DIR']

        self.logger.debug('output arg/output dir for series_analysis: ' +
                          self.get_output_path())

    def get_command(self):
        cmd = self.app_path + " "

        cmd += ' '.join(self.infiles)

        cmd += f" -config {self.c_dict['CONFIG_FILE']}"

        if self.get_output_path() == "":
            self.logger.info("No output directory specified, because series analysis has multiple directories")
            self.logger.info("No output filename specified, because series analysis has multiple files")
        else:
            cmd += " -out " + os.path.join(self.get_output_path())

        return cmd

    def generate_plots(self, sorted_filter_init, tile_dir):
        """! Generate the plots from the series_analysis output.
           Args:
               @param sorted_filter_init:  A list of the sorted directories
                                        corresponding to the init times (that
                                        are the result of filtering).  If
                                        filtering produced no results, this
                                        is the list of files created from
                                        running extract_tiles.

               @param tile_dir:  The directory where input data resides.
           Returns:
        """
        full_vars_list = feature_util.retrieve_var_name_levels(self.config)
        for cur_var in full_vars_list:
            name, level = cur_var
            for cur_init in sorted_filter_init:
                storm_list = self.get_storms_for_init(cur_init, tile_dir)
                for cur_storm in storm_list:
                    # create the output directory where the finished
                    # plots will reside
                    output_dir = os.path.join(self.c_dict['OUTPUT_DIR'], cur_init,
                                              cur_storm)
                    util.mkdir_p(output_dir)

                    fcst_path = os.path.join(output_dir,
                                             f"{self.FCST_ASCII_FILE_PREFIX}{cur_storm}")
                    # Now we need to invoke the MET tool
                    # plot_data_plane to generate plots that are
                    # recognized by the MET viewer.
                    # Get the number of forecast tile files,
                    # the name of the first and last in the list
                    # to be used by the -title option.
                    if tile_dir == self.c_dict['INPUT_DIR']:
                        # Since filtering was not requested, or
                        # the additional filtering doesn't yield results,
                        # search the output dir
                        num, beg, end = \
                            self.get_fcst_file_info(fcst_path)
                    else:
                        # Search the filtered output dir for
                        # the filtered files.
                        num, beg, end = self.get_fcst_file_info(fcst_path)

                    # Assemble the input file, output file, field string,
                    # and title
                    plot_data_plane_input_fname = self.c_dict.get('PLOTTING_DIR')
                    for cur_stat in self.c_dict['STAT_LIST']:
                        plot_data_plane_output = [output_dir,
                                                  '/series_',
                                                  name, '_',
                                                  level, '_',
                                                  cur_stat, '.ps']
                        plot_data_plane_output_fname = ''.join(
                            plot_data_plane_output)
                        os.environ['CUR_STAT'] = cur_stat
                        self.add_env_var('CUR_STAT', cur_stat)

                        # Create versions of the arg based on
                        # whether the background map is requested
                        # in param file.
                        map_data = ' map_data={ source=[];}'

                        if self.c_dict['BACKGROUND_MAP']:
                            # Flag set to True, draw background map.
                            field_string_parts = ["'name=", '"series_cnt_',
                                                  cur_stat, '";',
                                                  'level="', level, '";',
                                                  "'"]
                        else:
                            field_string_parts = ["'name=", '"series_cnt_',
                                                  cur_stat, '";',
                                                  'level="', level, '";',
                                                  map_data, "'"]

                        field_string = ''.join(field_string_parts)
                        title_parts = [f" -title \"{self.c_dict['MODEL']} Init ", cur_init,
                                       ' Storm ', cur_storm, ' ',
                                       str(num), ' Forecasts (',
                                       str(beg), ' to ', str(end),
                                       '),', cur_stat, ' for ',
                                       name, ', ',  level, '"']
                        title = ''.join(title_parts)

                        # Now assemble the entire plot data plane command
                        data_plane_command_parts = \
                            [self.c_dict['PLOT_DATA_PLANE'], ' ',
                             plot_data_plane_input_fname, ' ',
                             plot_data_plane_output_fname, ' ',
                             field_string, ' ', title]

                        data_plane_command = ''.join(
                            data_plane_command_parts)

                        # Since this wrapper is not using the CommandBuilder
                        # to build the cmd, we need to add the met verbosity
                        # level to the MET cmd created before we run
                        # the command.
                        data_plane_command = self.cmdrunner.insert_metverbosity_opt\
                            (data_plane_command)
                        (ret, cmd) = self.cmdrunner.run_cmd\
                            (data_plane_command, env=None, app_name=self.app_name)

                        if ret != 0:
                            self.log_error(f"MET command returned a non-zero return code: {cmd}")
                            self.logger.info("Check the logfile for more information on why it failed")

                        # Now assemble the command to convert the
                        # postscript file to png
                        png_fname = plot_data_plane_output_fname.replace(
                            '.ps', '.png')
                        convert_parts = [self.c_dict['CONVERT_EXE'], ' -rotate 90',
                                         ' -background white -flatten ',
                                         plot_data_plane_output_fname,
                                         ' ', png_fname]
                        convert_command = ''.join(convert_parts)

                        (ret, cmd) = self.cmdrunner.run_cmd(convert_command, ismetcmd=False)
                        if ret != 0:
                            self.log_error(f"MET command returned a non-zero return code: {cmd}")
                            self.logger.info("Check the logfile for more information on why it failed")

    def get_storms_for_init(self, cur_init, out_dir_base):
        """! Retrieve all the filter files which have the .tcst
             extension.  Inside each file, extract the STORM_ID
             and append to the list, if the storm_list directory
             exists.

            Args:
              @param cur_init: the init time

              @param out_dir_base:  The directory where one should start
                                    searching for the filter file(s)
                                    - those with a .tcst file extension.


        Returns:
            storm_list: A list of all the storms ids that correspond to
                        this init time and actually has a directory in the
                        init dir (additional filtering in a previous step
                        may result in missing storm ids even though they are
                        in the filter.tcst file)
        """
        # Retrieve filter files, first create the filename
        # by piecing together the out_dir_base with the cur_init.

        filter_filename = "filter_" + cur_init + ".tcst"
#        filter_file = os.path.join(out_dir_base, cur_init, filter_filename)
        filter_file = os.path.join(self.c_dict['FILTERED_OUTPUT_DIR'],
                                   cur_init, filter_filename)

        # Now that we have the filter filename for the init time, let's
        # extract all the storm ids in this filter file.
        storm_list = util.get_storm_ids(filter_file, self.logger)

        return storm_list

    def create_fcst_anly_to_ascii_file(self, fcst_anly_grid_files, cur_init,
                                       cur_storm, fcst_anly_filename_base):
        """! Create ASCII file for either the FCST or ANLY files that are
             aggregated based on init time and storm id.

        Args:
            fcst_anly_grid_files:       A list of the FCST or ANLY gridded
                                        files under consideration.

            cur_init:                  The initialization time of interest

            cur_storm:                 The storm id of interest

            fcst_anly_filename_base:   The base name of the ASCII file
                                        (either ANLY_ASCII_FILES_ or
                                        FCST_ASCII_FILES_ which will be
                                        appended with the storm id.

        Returns:
            None:                      Creates an ASCII file containing a list
                                        of either FCST or ANLY files based on
                                        init time and storm id.
        """
        # Create an ASCII file containing a list of all
        # the fcst or analysis tiles.
        fcst_anly_ascii_fname_parts = [fcst_anly_filename_base, cur_storm]
        fcst_anly_ascii_fname = ''.join(fcst_anly_ascii_fname_parts)
        fcst_anly_ascii_dir = os.path.join(self.c_dict['OUTPUT_DIR'], cur_init,
                                           cur_storm)
        util.mkdir_p(fcst_anly_ascii_dir)
        fcst_anly_ascii = os.path.join(fcst_anly_ascii_dir,
                                       fcst_anly_ascii_fname)

        # Sort the files in the fcst_anly_grid_files list.
        sorted_fcst_anly_grid_files = sorted(fcst_anly_grid_files)
        tmp_param = ''
        for cur_fcst_anly in sorted_fcst_anly_grid_files:
            # Write out the files that pertain to this storm and
            # don't write if already in tmp_param.
            if cur_fcst_anly not in tmp_param and cur_storm in cur_fcst_anly:
                tmp_param += cur_fcst_anly
                tmp_param += '\n'
        # Now create the fcst or analysis ASCII file
        try:
            with open(fcst_anly_ascii, 'w') as filehandle:
                filehandle.write(tmp_param)
        except IOError:
            msg = ("Could not create requested ASCII file:  " +
                   fcst_anly_ascii)
            self.log_error(msg)

        if os.stat(fcst_anly_ascii).st_size == 0:
            # Just in case there are any empty fcst ASCII or anly ASCII files
            # at this point,
            # explicitly remove them (and any resulting empty directories)
            #  so they don't cause any problems with further processing
            # steps.
            util.prune_empty(fcst_anly_ascii_dir, self.logger)
